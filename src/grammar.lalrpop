use crate::ast::*;
use crate::utils::*;

use std::str::FromStr;

grammar;

pub program: Program = {
    <stmts:statement*> => Program::new(stmts)
}

statement: Statement = {
    "use" <args:import_args> ";" => Statement::ImportStatement(args),
    <expr:expr> ";" => Statement::ExpressionStatement(expr),
    <name:identifier> "=" <rhs:expr> ";" => Statement::AssignmentStatement(name, rhs),
    "let" <name:identifier> "=" <rhs:expr> ";" => Statement::LetStatement(name, rhs),

}

import_args: Vec<String> = {
    <args:import_args> "::" <name:identifier> => append(args, name),
    <name:identifier> => vec![name],
}

expr: Expression = {
    <objects:expr> "." <tail:term_>  => Expression::MethodCall(Box::new(objects), Box::new(tail)),
    <head:term> => head,
}

term: Expression = {
    <n:int> => Expression::Int(n),
    <s:string> => Expression::String(s),
    <b:bool> => Expression::Bool(b),
    <l:list> => Expression::List(l),
    <name:identifier> "(" <args:args> ")" => Expression::Call(name, args),
    <head:expr> "[" <tail:expr> "]" => Expression::Index(Box::new(head), Box::new(tail)),
    <name:identifier> => Expression::Identifier(name),
    "(" <head:term> ")" => head,
}

term_: Expression = {
    <name:identifier> "(" <args:args> ")" => Expression::Call(name, args),
    <name:identifier> => Expression::Identifier(name),
}

args: Vec<Expression> = {
    () => vec![],
    <args:args> "," <e:expr> => append(args, e),
    <e:expr> => vec![e]
}

int: i32 = {
    <n:r"-?[0-9]+"> => i32::from_str(n).unwrap()
};

string: String = {
    <s:r#""[^"]*""#> => s[1..s.len() - 1].to_owned()
};

list: Vec<Expression> = {
    "[" <head:args> "]" => head,
}

bool: bool = {
    "true" => true,
    "false" => false
}

identifier: String = {
    <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> => s.to_owned()
}
