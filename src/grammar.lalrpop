use crate::ast::*;
use crate::utils::*;

use std::str::FromStr;

grammar;

pub program: Program = {
    <stmts:statement*> => Program::new(stmts)
}

statement: Statement = {
    <expr:expr> ";" => Statement::Expression(expr),
    <name:identifier> "=" <rhs:expr> ";" => Statement::Assignment(name, rhs),
    "let" <name:identifier> "=" <rhs:expr> ";" => Statement::Let(name, rhs),
    "const" <name:identifier> "=" <rhs:expr> ";" => Statement::Const(name, rhs),
    "fn" <name:identifier> "(" <params:params> ")" <block:block> => Statement::Fn(name, params, block),
    "return" <expr:expr> ";" => Statement::Return(expr),
    "import" <args:import_args> ";" => Statement::Import(args, None),
    "import" <args:import_args> "::" "{" <names:params> "}" ";" => Statement::Import(args, Some(names)),
    "for" <lhs:identifier> "in" <iter:expr> <block:block> => Statement::For(lhs, iter, block),
    "break" ";" => Statement::Break,
    "continue" ";" => Statement::Continue,
    "while" <cond:expr> <block:block> => Statement::While(cond, block),
    "module" <name:identifier> <block:block> => Statement::Module(name, block),
    if_statement,
}

if_statement: Statement = {
    "if" <cond:expr> <if_block:block> => Statement::If(vec![Branch::new(cond, if_block)], None),
    "if" <cond:expr> <if_block:block> "else" <else_block:block> => Statement::If(vec![Branch::new(cond, if_block)], Some(else_block)),
    "if" <cond:expr> <if_block:block> "else" <else_if_stmts:if_statement> => {
        if let Statement::If(mut branches, else_stmt) = else_if_stmts {
            branches.insert(0, Branch::new(cond, if_block));
            return Statement::If(branches, else_stmt);
        } else {
            panic!("grammar error: if statement");
        }
    }
}

if_expr: Expr = {
    "if" <cond:expr> <if_block:block> => Expr::If(vec![Branch::new(cond, if_block)], None),
    "if" <cond:expr> <if_block:block> "else" <else_block:block> => Expr::If(vec![Branch::new(cond, if_block)], Some(else_block)),
    "if" <cond:expr> <if_block:block> "else" <else_if_stmts:if_expr> => {
        if let Expr::If(mut branches, else_stmt) = else_if_stmts {
            branches.insert(0, Branch::new(cond, if_block));
            return Expr::If(branches, else_stmt);
        } else {
            panic!("grammar error: if statement");
        }
    }
}

import_args: Vec<String> = {
    <args:import_args> "::" <name:identifier> => append(args, name),
    <name:identifier> => vec![name],
}

expr: Expr = {
    expr_1
}

expr_1: Expr = {
    <lhs:expr> "||" <rhs:expr_2> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::Or, Box::new(rhs)),
    <lhs:expr> "&&" <rhs:expr_2> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::And, Box::new(rhs)),
    expr_2
}

expr_2: Expr = {
    <start:expr_4> ".." <end:expr_4> => Expr::Range(Box::new(start), Box::new(end)),

     <lhs:expr_2> "==" <rhs:expr_3> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::EQ, Box::new(rhs)),
     <lhs:expr_2> "!=" <rhs:expr_3> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::NE, Box::new(rhs)),
     <lhs:expr_2> ">" <rhs:expr_3> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::GT, Box::new(rhs)),
     <lhs:expr_2> "<" <rhs:expr_3> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::LT, Box::new(rhs)),
     <lhs:expr_2> ">=" <rhs:expr_3> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::GTE, Box::new(rhs)),
     <lhs:expr_2> "<=" <rhs:expr_3> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::LTE, Box::new(rhs)),
     expr_3
}

expr_3: Expr = {
    <lhs:expr_3> "+" <rhs:expr_4> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::Add, Box::new(rhs)),
    <lhs:expr_3> "-" <rhs:expr_4> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::Sub, Box::new(rhs)),
    expr_4
}

expr_4: Expr = {
    "!" <expr:expr_5> => Expr::UnaryOp(UnaryOpKind::Not, Box::new(expr)),   
    "typeof" <expr:expr_5> => Expr::UnaryOp(UnaryOpKind::Typeof, Box::new(expr)),
    "fn" "(" <params:params> ")" <block:block>  => Expr::Fn(params, block),
    "module" <block:block> => Expr::Module(block),

    if_expr,
        
    <lhs:expr_4> "*" <rhs:expr_5> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::Mul, Box::new(rhs)),
    <lhs:expr_4> "/" <rhs:expr_5> => Expr::BinaryOp(Box::new(lhs), BinaryOpKind::Div, Box::new(rhs)),
    expr_5
}

expr_5: Expr = {
    <head:import_args> "::" <tail:expr_6> => Expr::ModuleCall(head, Box::new(tail)),
    
    expr_6
}

expr_6: Expr = {
    <head:expr_6> "." <tail:expr_7> => Expr::MethodCall(Box::new(head), Box::new(tail)),
    <head:expr_6> "[" <tail:expr> "]" => Expr::Index(Box::new(head), Box::new(tail)),
    <expr:expr_6> "(" <args:args> ")" => Expr::Call(Box::new(expr), args),
    "{" <props:props> ","? "}" => Expr::Object(props),
    "(" <expr:expr> "," <exprs:args> ")" => Expr::Tuple(append(exprs, expr)),

    expr_7
}

expr_7: Expr = {
    "null" => Expr::Null,
    <n:int> => Expr::Int(n),
    <f:float> => Expr::Float(f),
    <s:string> => Expr::String(s),
    <b:bool> => Expr::Bool(b),
    <l:list> => Expr::List(l),
    <name:identifier> => Expr::Identifier(name),
    "(" <expr:expr> ")" => expr
}

props: Vec<Prop> = {
    <props:props> "," <prop:prop> => append(props, prop),
    <prop:prop> => vec![prop],
    () => vec![]
}

prop: Prop = {
    <key:identifier> ":" <value:expr> => Prop { key, value }
}

args: Vec<Expr> = {
    () => vec![],
    <args:args> "," <e:expr> => append(args, e),
    <e:expr> => vec![e]
}

params: Vec<String> = {
    () => vec![],
    <params:params> "," <param:identifier> => append(params, param),
    <param:identifier> => vec![param]
}

block: Block = {
    "{" <stmts:statement*> "}" => stmts,
}

int: i32 = {
    <n:r"-?[0-9]+"> => i32::from_str(n).unwrap()
};

float: f32 = {
    <n:r"-?[0-9]+.[0-9]+"> => f32::from_str(n).unwrap()
};

string: String = {
    <s:r#""[^"]*""#> => s[1..s.len() - 1].to_owned()
};

list: Vec<Expr> = {
    "[" <head:args> "]" => head,
}

bool: bool = {
    "true" => true,
    "false" => false
}

identifier: String = {
    <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> => s.to_owned()
}

match {
    r"-?[0-9]+",
    r#""[^"]*""#,
    r"[a-zA-Z_][a-zA-Z_0-9]*",
    "import",
    ";",
    "@(",
    "let",
    "=", 
    "/", 
    "::", 
    "*", 
    ">", 
    "<",  
    "||", 
    "&&", 
    ".", 
    "..",
    "<=", 
    ">=", 
    "+", 
    "-", 
    "==", 
    "!=", 
    "!", 
    "_", 
    "true", 
    "false", 
    "[", 
    "]", 
    "(", 
    ")", 
    "null", 
    ",",
    ":",
    "if",
    "else",
    "{",
    "}", 
    "return",
    "fn",
    "for",
    "in",
    "break",
    "continue",
    "while",
    "const",
    "typeof",
    "module"
} else {
    " " => {},
    "\n" => {},
    "\r" => {},
    r"-?[0-9]+.[0-9]+",
    r"#.*" => {}
}
